4893
((3) 0 () 1 ((q lib "heresy/main.rkt")) () (h ! (equal) ((c def c (c (? . 0) q instr)) q (4927 . 4)) ((c def c (c (? . 0) q even?)) q (5845 . 3)) ((c form c (c (? . 0) q rem)) q (1768 . 2)) ((c def c (c (? . 0) q /)) q (5292 . 6)) ((c def c (c (? . 0) q sin)) q (6150 . 3)) ((c def c (c (? . 0) q join)) q (2196 . 4)) ((c def c (c (? . 0) q atom?)) q (1195 . 3)) ((c form c (c (? . 0) q ?)) q (1999 . 2)) ((c form c (c (? . 0) q Self)) q (6779 . 2)) ((c def c (c (? . 0) q mid)) q (3213 . 5)) ((c def c (c (? . 0) q True)) q (1398 . 2)) ((c def c (c (? . 0) q right$)) q (4609 . 4)) ((c def c (c (? . 0) q left)) q (3076 . 4)) ((c form c (c (? . 0) q unquote)) q (1515 . 3)) ((c def c (c (? . 0) q exp)) q (6100 . 3)) ((c def c (c (? . 0) q zero?)) q (916 . 3)) ((c def c (c (? . 0) q len$)) q (4315 . 3)) ((c def c (c (? . 0) q zipwith)) q (3920 . 5)) ((c def c (c (? . 0) q -)) q (5180 . 6)) ((c def c (c (? . 0) q left$)) q (4532 . 4)) ((c def c (c (? . 0) q split)) q (5023 . 4)) ((c def c (c (? . 0) q foldl)) q (2714 . 5)) ((c def c (c (? . 0) q False)) q (1422 . 2)) ((c def c (c (? . 0) q symbol?)) q (1144 . 3)) ((c form c (c (? . 0) q range)) q (2348 . 3)) ((c form c (c (? . 0) q for)) q (584 . 3)) ((c def c (c (? . 0) q +)) q (5127 . 3)) ((c form c (c (? . 0) q if)) q (340 . 2)) ((c form c (c (? . 0) q print)) q (1943 . 5)) ((c def c (c (? . 0) q assoc)) q (3551 . 4)) ((c def c (c (? . 0) q right)) q (3144 . 4)) ((c def c (c (? . 0) q error)) q (1571 . 6)) ((c def c (c (? . 0) q sort)) q (3776 . 4)) ((c def c (c (? . 0) q zip)) q (3851 . 4)) ((c def c (c (? . 0) q sgn)) q (5950 . 3)) ((c def c (c (? . 0) q dec)) q (6050 . 3)) ((c def c (c (? . 0) q slice$)) q (4792 . 5)) ((c def c (c (? . 0) q head$)) q (4420 . 3)) ((c def c (c (? . 0) q randomize)) q (6300 . 3)) ((c form c (c (? . 0) q carry)) q (785 . 2)) ((c def c (c (? . 0) q list&)) q (4370 . 3)) ((c def c (c (? . 0) q apply)) q (1843 . 5)) ((c def c (c (? . 0) q abs)) q (5795 . 3)) ((c def c (c (? . 0) q odd?)) q (5898 . 3)) ((c def c (c (? . 0) q index)) q (2861 . 4)) ((c def c (c (? . 0) q *)) q (5405 . 3)) ((c def c (c (? . 0) q compose)) q (6945 . 4)) ((c form c (c (? . 0) q unquote-splicing)) q (1538 . 3)) ((c def c (c (? . 0) q send)) q (6668 . 5)) ((c form c (c (? . 0) q def)) q (0 . 2)) ((c def c (c (? . 0) q =$)) q (4021 . 4)) ((c def c (c (? . 0) q filter)) q (2492 . 4)) ((c def c (c (? . 0) q foldr)) q (2617 . 5)) ((c def c (c (? . 0) q &)) q (4092 . 3)) ((c def c (c (? . 0) q append)) q (3497 . 3)) ((c form c (c (? . 0) q do)) q (670 . 2)) ((c form c (c (? . 0) q fn)) q (305 . 2)) ((c def c (c (? . 0) q inlst)) q (3007 . 4)) ((c form c (c (? . 0) q input)) q (2016 . 5)) ((c def c (c (? . 0) q >)) q (5608 . 4)) ((c form c (c (? . 0) q using)) q (2081 . 2)) ((c def c (c (? . 0) q cos)) q (6200 . 3)) ((c form c (c (? . 0) q cry)) q (807 . 2)) ((c def c (c (? . 0) q mid$)) q (4687 . 5)) ((c def c (c (? . 0) q len)) q (2569 . 3)) ((c def c (c (? . 0) q <)) q (5533 . 4)) ((c def c (c (? . 0) q tan)) q (6250 . 3)) ((c form c (c (? . 0) q describe)) q (6430 . 2)) ((c form c (c (? . 0) q or)) q (1316 . 2)) ((c def c (c (? . 0) q list?)) q (818 . 3)) ((c def c (c (? . 0) q pi)) q (5683 . 2)) ((c def c (c (? . 0) q null?)) q (867 . 3)) ((c def c (c (? . 0) q not)) q (1339 . 3)) ((c def c (c (? . 0) q inc)) q (6000 . 3)) ((c def c (c (? . 0) q Null)) q (1447 . 2)) ((c def c (c (? . 0) q heads)) q (3728 . 3)) ((c def c (c (? . 0) q e)) q (5704 . 2)) ((c def c (c (? . 0) q reverse)) q (2811 . 3)) ((c def c (c (? . 0) q list)) q (2146 . 3)) ((c def c (c (? . 0) q str$)) q (4205 . 3)) ((c def c (c (? . 0) q =)) q (5458 . 4)) ((c def c (c (? . 0) q subst)) q (3629 . 5)) ((c form c (c (? . 0) q break)) q (755 . 3)) ((c def c (c (? . 0) q append1)) q (3424 . 4)) ((c def c (c (? . 0) q slice)) q (3305 . 5)) ((c def c (c (? . 0) q tail$)) q (4476 . 3)) ((c def c (c (? . 0) q tail)) q (2303 . 3)) ((c def c (c (? . 0) q partial)) q (6855 . 4)) ((c def c (c (? . 0) q run)) q (1720 . 3)) ((c form c (c (? . 0) q and)) q (1292 . 2)) ((c def c (c (? . 0) q index*)) q (2928 . 4)) ((c def c (c (? . 0) q head)) q (2258 . 3)) ((c form c (c (? . 0) q quasiquote)) q (1489 . 3)) ((c form c (c (? . 0) q let)) q (203 . 2)) ((c def c (c (? . 0) q lat?)) q (1244 . 3)) ((c form c (c (? . 0) q file)) q (2116 . 2)) ((c form c (c (? . 0) q else)) q (1386 . 2)) ((c def c (c (? . 0) q mod)) q (5724 . 4)) ((c def c (c (? . 0) q empty$?)) q (4256 . 3)) ((c def c (c (? . 0) q one?)) q (965 . 3)) ((c def c (c (? . 0) q rnd)) q (6377 . 2)) ((c form c (c (? . 0) q select)) q (384 . 3)) ((c form c (c (? . 0) q quote)) q (1468 . 3)) ((c def c (c (? . 0) q eq?)) q (1013 . 4)) ((c def c (c (? . 0) q list$)) q (4149 . 3)) ((c def c (c (? . 0) q Y)) q (6799 . 3)) ((c def c (c (? . 0) q equal?)) q (1077 . 4)) ((c def c (c (? . 0) q map)) q (2418 . 4)) ((c def c (c (? . 0) q timer)) q (6406 . 2))))
syntax
(def name value)
syntax
(def fn name args body ...+)
 
args = (arg ...)
     | (arg ... . rest-id)
     | args-id
        
 arg = arg-id
     | [arg-id default-expr]
syntax
(let ((name value) ...) body ...+)
syntax
(let proc-id ((name value) ...) body ...)
syntax
(fn (arg ...) body ...)
syntax
(if test then texpr else fexpr)
syntax
(select (test1 expr1) ...)
(select (test1 expr1) ... (else fexpr))
syntax
(select case texpr ((val ...) rexpr) ...)
(select case texpr ((val ...) rexpr) ... (else fexpr))
syntax
(for (var in list) body ...)
(for (var in list with cry) body ...)
syntax
(do body ...)
syntax
(do loop body ...)
(do loop with cry body ...)
syntax
(break)
(break value)
syntax
(carry value)
syntax
cry
procedure
(list? v) -> boolean?
  v : any
procedure
(null? v) -> boolean?
  v : any
procedure
(zero? v) -> boolean?
  v : any
procedure
(one? v) -> boolean?
  v : any
procedure
(eq? x y) -> boolean?
  x : any
  y : any
procedure
(equal? x y) -> boolean?
  x : any
  y : any
procedure
(symbol? v) -> boolean?
  v : any
procedure
(atom? v) -> boolean?
  v : any
procedure
(lat? l) -> boolean?
  l : any
syntax
(and expr ...)
syntax
(or expr ...)
procedure
(not v) -> boolean?
  v : any
syntax
else
value
True : boolean?
value
False : boolean?
value
Null : null?
syntax
(quote v)
'v
syntax
(quasiquote v)
`v
syntax
(unquote v)
,v
syntax
(unquote-splicing v)
,@v
procedure
(error message) -> nothing
  message : string?
(error symbol message) -> nothing
  symbol : symbol?
  message : string?
procedure
(run form) -> any
  form : any
syntax
(rem any ...)
syntax
(def macro name (pattern ...) template)
procedure
(apply fun v ... lst) -> any
  fun : procedure?
  v : any
  lst : list?
syntax
(print v)
(print & v)
(print lit v)
(print)
syntax
(? ....)
syntax
(input)
(input stx)
(input string)
(input stx string)
syntax
(using io-port body ...)
syntax
(file name as mode)
procedure
(list v ...) -> list?
  v : any
procedure
(join a b) -> pair?
  a : any
  b : any
procedure
(head l) -> any
  l : list?
procedure
(tail l) -> any
  l : list?
syntax
(range start to finish)
(range start to finish step n)
procedure
(map fun l) -> list?
  fun : procedure?
  l : list?
procedure
(filter fun l) -> list?
  fun : procedure?
  l : list?
procedure
(len l) -> number?
  l : list?
procedure
(foldr fun base l) -> any
  fun : procedure?
  base : any
  l : list?
procedure
(foldl fun base l) -> any
  fun : procedure?
  base : any
  l : list?
procedure
(reverse l) -> list?
  l : list?
procedure
(index n l) -> any
  n : number?
  l : list?
procedure
(index* l dims ...) -> any
  l : list?
  dims : number?
procedure
(inlst item l) -> any
  item : any
  l : list?
procedure
(left l n) -> list?
  l : list?
  n : number?
procedure
(right l n) -> list?
  l : list?
  n : number?
procedure
(mid l idx n) -> list?
  l : list?
  idx : number?
  n : number?
procedure
(slice l first [last]) -> list?
  l : list?
  first : number?
  last : number? = (len l)
procedure
(append1 l1 l2) -> list?
  l1 : list?
  l2 : list?
procedure
(append l ...) -> list?
  l : list?
procedure
(assoc tgt l) -> list-or-false?
  tgt : any
  l : list?
procedure
(subst tgt new l) -> list-or-false?
  tgt : any
  new : any
  l : list?
procedure
(heads l) -> list?
  l : list?
procedure
(sort fun l) -> list?
  fun : procedure?
  l : list?
procedure
(zip l1 l2) -> list?
  l1 : list?
  l2 : list?
procedure
(zipwith fun l1 l2) -> list?
  fun : procedure?
  l1 : list?
  l2 : list?
procedure
(=$ x y) -> boolean?
  x : string?
  y : string?
procedure
(& str ...) -> string?
  str : string?
procedure
(list$ str) -> string?
  str : string?
procedure
(str$ n) -> string?
  n : number?
procedure
(empty$? str) -> boolean?
  str : string?
procedure
(len$ str) -> number?
  str : string?
procedure
(list& l) -> string?
  l : list?
procedure
(head$ str) -> string?
  str : string?
procedure
(tail$ str) -> string?
  str : string?
procedure
(left$ str n) -> string?
  str : string?
  n : number?
procedure
(right$ str n) -> string?
  str : string?
  n : number?
procedure
(mid$ str idx len) -> string?
  str : string?
  idx : number?
  len : number?
procedure
(slice$ str start [finish]) -> string?
  str : string?
  start : number?
  finish : number? = (len$ str)
procedure
(instr str search) -> number-or-false?
  str : string?
  search : string?
procedure
(split str [delimiters]) -> list?
  str : string?
  delimiters : list? = '(" ")
procedure
(+ x ...) -> number?
  x : number?
procedure
(- x y ...+) -> number?
  x : number?
  y : nuber?
(- x) -> number?
  x : number?
procedure
(/ x y ...+) -> number?
  x : number?
  y : number?
(/ x) -> number?
  x : number?
procedure
(* x ...) -> number?
  x : number?
procedure
(= x y ...) -> boolean?
  x : number?
  y : number?
procedure
(< x y ...) -> boolean?
  x : number?
  y : number?
procedure
(> x y ...) -> boolean?
  x : number?
  y : number?
value
pi : number?
value
e : number?
procedure
(mod x y) -> number?
  x : number?
  y : number?
procedure
(abs n) -> number?
  n : number?
procedure
(even? n) -> boolean?
  n : number?
procedure
(odd? n) -> boolean?
  n : number?
procedure
(sgn n) -> number?
  n : number?
procedure
(inc n) -> number?
  n : number?
procedure
(dec n) -> number?
  n : number?
procedure
(exp x) -> number?
  x : number?
procedure
(sin x) -> number?
  x : number?
procedure
(cos x) -> number?
  x : number?
procedure
(tan x) -> number?
  x : number?
procedure
(randomize [seed]) -> procedure?
  seed : number? = timer
procedure
(rnd) -> number?
value
timer : number?
syntax
(describe Name (field value) ...)

(Name)
(Name symbol)
(Name 'fields)
(Name pattern)

(Name)

(Name 'fields)

(Name symbol)

(Name pattern)
 
pattern = `(sub-pat ...)
           
sub-pat = *
        | value
procedure
(send Thing symbol arg ...) -> any
  Thing : thing?
  symbol : symbol?
  arg : any
syntax
(Self ....)
procedure
(Y fn) -> procedure?
  fn : procedure?
procedure
(partial fun arg ...) -> procedure?
  fun : procedure?
  arg : any
procedure
(compose fn1 fn2) -> procedure?
  fn1 : procedure?
  fn2 : procedure?
