#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Heresy Programming Language
\end_layout

\begin_layout Author
John S.
 Berry III
\end_layout

\begin_layout Abstract
The Heresy language is a functional Lisp/Scheme dialect implemented in Racket,
 with syntax inspired by the BASIC family of programming languages.
 It's principle goals are to provide a simple core language for BASIC and
 other programmers to experiment with and learn how to program functionally.
 This document will detail the general philosophy of the Heresy language,
 such as exists, as well as the language syntax and functions.
 
\begin_inset Newline newline
\end_inset

The Heresy language was created by John S.
 Berry III with additional contributions from many others in the Racket
 community.
 
\begin_inset Newline newline
\end_inset

Heresy and this documentation are Copyright (c) 2014 John S.
 Berry III and released under the terms of the GNU LGPL.
\end_layout

\begin_layout Section
The Heresy Rules
\end_layout

\begin_layout Standard
The Heresy language is developed according to a few basic "ground rules,"
 which the author and contributors attempt to follow in developing new features
 and functions for the language.
 These are as follows:
\end_layout

\begin_layout Enumerate

\series bold
Heresy is BASIC
\series default
 - Heresy is inspired by BASIC, and aims to be at least somewhat easy for
 BASIC programmers to learn.
 Mostly this means we prefer BASIC names for functions over the Lisp name,
 and naming conventions like the $ for string functions.
\end_layout

\begin_layout Enumerate

\series bold
Heresy is a Lisp
\series default
 - Heresy is still a Lisp, and loves simple syntax and s-expressions.
 While it makes use of some sugaring like literal keywords for certain common
 primitives, these are best used sparingly.
 Heresy is the Diet Coke of Evil, just one calorie, not quite evil enough.
\end_layout

\begin_layout Enumerate

\series bold
Heresy is functional 
\series default
- Functional, but not Haskell.
 It is not intended solely as a vehicle for absolute functional purity.
 I love Haskell.
 You love Haskell.
 We don’t need to write another Haskell.
 Think more in terms of a lower-calorie, more intelligible Clojure.
\end_layout

\begin_layout Enumerate

\series bold
Heresy is for learning
\series default
 - Heresy started as a learning project, a chance to learn how Lisp and
 functional programming really work on a practical level.
 I hope that, in time, it can be that for others as well, especially those
 who grew up with BASIC like myself and still sometimes struggle to get
 their head around the functional style.
 In particular, this means the Heresy-written portions of the source are
 generally written in as clear a manner as possible, as they are intended
 to be self-teaching.
\end_layout

\begin_layout Enumerate

\series bold
Heresy is an experiment
\series default
 - Heresy is an experimental language.
 It’s very DNA is as a mad idea that came to life, and it’s development
 should be ready and willing to embrace new mad ideas and run with them.
 This is where carry came from, and I hope to have more mad ideas in the
 future.
\end_layout

\begin_layout Enumerate

\series bold
Heresy is for everyone
\series default
 - As a statement of culture, the Heresy community welcomes the contribution
 of all people, who taste equally delicious to the jaws of mighty Cthulhu.
 No discrimination, harassment, or any other mistreatment of contributors
 on the basis of age, race, sexuality, or gender will 
\series bold
ever
\series default
 be tolerated by myself or anyone else who wishes to be part of this project.
\end_layout

\begin_layout Section
Heresy Syntax and Conventions
\end_layout

\begin_layout Standard
Generally speaking, Heresy follows standard s-expression syntax as expected
 from any Lisp, being composed of parenthesized sequences of terms in Polish
 notation.
 Each sequence thus begins with an operator or function, and any number
 of arguments or additional s-expressions as needed.
\end_layout

\begin_layout Standard
There are however a few exceptions to usual expectations in the case of
 certain special forms like for, def, and if.
 These make use of additional literal terms as part of their syntax, to
 provide more clarity and similarity to BASIC-style syntax.
\end_layout

\begin_layout Standard
In accordance with that goal, Heresy also follows certain naming conventions
 as a matter of style.
 Functions which produce a string value are appended with $, and in general
 where a naming conflict between two similar functions in Racket/Scheme
 and BASIC exists, prefer BASIC.
\end_layout

\begin_layout Standard
When borrowing BASIC syntax and naming for use in Heresy, the author has
 generally relied chiefly on QBASIC and ECMA BASIC for reference.
\end_layout

\begin_layout Section
Heresy Reference
\end_layout

\begin_layout Subsection
Declarations
\end_layout

\begin_layout LyX-Code
(def 
\emph on
name value
\emph default
)
\end_layout

\begin_layout Standard
Defines a new variable of 
\emph on
name
\emph default
 with the given 
\emph on
value.
\end_layout

\begin_layout LyX-Code
(def
\series bold
 
\series default
fn 
\emph on
name 
\emph default
([
\emph on
arg
\emph default
 ...]) 
\emph on
body
\emph default
 ...)
\end_layout

\begin_layout Standard
Defines a function of 
\emph on
name
\emph default
, which when called evaluates its body expressions with the given list of
 arguments bound to local variables for use in the body of the function's
 definition.
 Note that there are a number of additional options here for defining arguments.
 Default values can be ascribed to an argument by enclosing it in additional
 parentheses:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> (define foo (x (y 1)) (+ x y))
\end_layout

\begin_layout Plain Layout

> (foo 3 4)
\end_layout

\begin_layout Plain Layout

7
\end_layout

\begin_layout Plain Layout

> (foo 5)
\end_layout

\begin_layout Plain Layout

6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two patterns as well exist for taking an arbitrary number of values.
 The argument names list can be forgone entirely and substituted with a
 single name (generally
\emph on
 args*
\family typewriter
\emph default
 
\family default
by convention), which will then contain a list of any and all values passed
 to the function.
 The second method is the use of the dot (.) in the body of the arguments
 list followed by a single variable (usually called 
\emph on
rest
\emph default
).
\end_layout

\begin_layout LyX-Code
(let ((
\emph on
name value
\emph default
) ...) 
\emph on
body
\emph default
 ...)
\end_layout

\begin_layout Standard
Binds the given name-value pairs for use in the local context created by
 the body of the expression.
 This is used to define local variables, such as are needed within a function.
 Note that local functions can potentially be assigned this way by storing
 anonymous functions, but there is a built-in syntax for defining a single
 such function, like so:
\end_layout

\begin_layout LyX-Code
(let 
\emph on
proc
\emph default
 ((
\emph on
name value) ...
\emph default
) 
\emph on
body ...
\emph default
)
\end_layout

\begin_layout Standard
When 
\emph on
let
\emph default
 is called this way, it defines a local function 
\emph on
proc
\emph default
 (conventionally called 
\emph on
recur
\emph default
), which can then be called from within the body of the 
\emph on
let
\emph default
 in order to perform local recursion; the name-value pairs thus act as arguments
 to the function 
\emph on
proc
\emph default
.
 
\end_layout

\begin_layout LyX-Code
(fn ([
\emph on
arg ...
\emph default
]) 
\emph on
body ...
\emph default
)
\end_layout

\begin_layout Standard
Creates an anonymous function with the given arguments, that evaluates its
 body when called.
 This is the 
\emph on
lambda
\emph default
 expression from other Lisps and functional languages, and a given 
\emph on
fn
\emph default
 can be passed as a value (as can named functions, for that matter) wherever
 called for.
 An anonymous function can also be evaluated directly in place by using
 it as the operator in an expression, like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> ((fn (x y) (* x y)) 4 5)
\end_layout

\begin_layout Plain Layout

20
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Conditionals and Loops
\end_layout

\begin_layout LyX-Code
(if 
\emph on
test
\emph default
 then 
\emph on
texpr 
\emph default
else 
\emph on
fexpr
\emph default
)
\end_layout

\begin_layout Standard
Evalutes 
\emph on
test
\emph default
 and, if 
\emph on
test 
\emph default
is True, evaluates 
\emph on
texpr
\emph default
, otherwise it evaluates 
\emph on
fexpr.

\emph default
 Note that only a single expression can be placed in each 
\begin_inset Quotes eld
\end_inset

slot
\begin_inset Quotes erd
\end_inset

 in the syntax; if you need to do multiple things, use a 
\emph on
do
\emph default
 block.
 
\end_layout

\begin_layout LyX-Code
(select (
\emph on
test1 expr1) ...
 
\emph default
[(else 
\emph on
fexpr
\emph default
)])
\end_layout

\begin_layout Standard
Given a list of test-expression pairs, evaluates the tests in order until
 it finds one which is True, and evaluates the matching expression.
 The 
\emph on
else
\emph default
 expression is always true: if an else is found at the end of the 
\emph on
select
\emph default
 statement, its matching 
\emph on
fexpr
\emph default
 will be evaluated.
 If no test in 
\emph on
select
\emph default
 is true, returns 
\emph on
#<void>.
\end_layout

\begin_layout LyX-Code
(select case 
\emph on
texpr 
\emph default
((
\emph on
val ...
\emph default
) 
\emph on
rexpr
\emph default
) ...
 [(else 
\emph on
fexpr
\emph default
)])
\end_layout

\begin_layout Standard
Evaluates 
\emph on
texpr 
\emph default
and compares it to 
\emph on
vals
\emph default
 in turn until it finds a value that is 
\emph on
eq?
\emph default
 to the result of 
\emph on
texpr.
 
\emph default
If one is found, it evaluates the matching 
\emph on
rexpr
\emph default
.
 Like with 
\emph on
select
\emph default
, 
\emph on
else
\emph default
 is always considered True, and will therefore always evaluate its 
\emph on
fexpr.
 
\emph default
If no matching 
\emph on
val
\emph default
 is found, 
\emph on
select case
\emph default
 evaluates to 
\emph on
#<void>.

\emph default
 Not also that the 
\emph on
(val ...) 
\emph default
is a list, and can contain as many values as is needed, such as in the following
 example: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> (select case (* 2 3)
\end_layout

\begin_layout Plain Layout

    ((2 3 4) (print "Nope."))
\end_layout

\begin_layout Plain Layout

    ((5 6 7) (print "Yup."))
\end_layout

\begin_layout Plain Layout

    (else (print "something is horribly wrong.")))
\end_layout

\begin_layout Plain Layout

Yup.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
(for (
\emph on
var 
\emph default
in 
\emph on
list
\emph default
 [with 
\emph on
cry
\emph default
]) 
\emph on
body ...
\emph default
)
\end_layout

\begin_layout Standard
Iterates over 
\emph on
list
\emph default
 evaluating it's body with the 
\emph on
head
\emph default
 of 
\emph on
list 
\emph default
assigned to 
\emph on
var
\emph default
, then recurs with the 
\emph on
tail
\emph default
 of 
\emph on
list
\emph default
 until it returns Null.
 
\emph on
for 
\emph default
loops declare an implicit variable 
\emph on
cry 
\emph default
which can be passed a value with 
\emph on
carry.
 
\emph default
They may also be interrupted with 
\emph on
break.
 
\emph default
See below for more details.
\end_layout

\begin_layout LyX-Code
(do 
\emph on
body ...
\emph default
)
\end_layout

\begin_layout Standard
Evaluates its body in order, returning the result of the final body expression.
\end_layout

\begin_layout LyX-Code
(do loop [with 
\emph on
cry
\emph default
] 
\emph on
body ...
\emph default
)
\end_layout

\begin_layout Standard
Evaluates 
\emph on
body
\emph default
 repeatedly until a 
\emph on
break
\emph default
 statement is encountered.
 Declares the implicit variable 
\emph on
cry, 
\emph default
which can be reassigned with the 
\emph on
carry 
\emph default
operator
\emph on
.
\end_layout

\begin_layout LyX-Code
(break [
\emph on
value
\emph default
])
\end_layout

\begin_layout Standard
Breaks the continuation of a 
\emph on
for 
\emph default
or 
\emph on
do loop
\emph default
 evaluation.
 If provided a value, returns that value as the result of the loop.
\end_layout

\begin_layout LyX-Code
(carry 
\emph on
value
\emph default
)
\end_layout

\begin_layout Standard
When called in the body of a 
\emph on
for 
\emph default
or 
\emph on
do loop
\emph default
 expression, immediately begins the next iteration of the loop, and passes
 the given value to the implicit variable 
\emph on
cry
\emph default
.
\end_layout

\begin_layout LyX-Code
cry
\end_layout

\begin_layout Standard
Loops declare an internal variable called 
\emph on
cry, 
\emph default
which defaults to Null, and which is passed automatically to the next iteration
 of the loop, and is returned when the loop concludes.
 The value of 
\emph on
cry
\emph default
 can be specified at the beginning of the loop with the optional 
\emph on
with 
\emph default
parameter, and 
\emph on
carry 
\emph default
can be used to pass a new value of 
\emph on
cry 
\emph default
to the next iteration.
\end_layout

\begin_layout Subsection
Predicates and Logic
\end_layout

\begin_layout LyX-Code
(list? 
\emph on
v
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
v
\emph default
 is a list.
\end_layout

\begin_layout LyX-Code
(null? 
\emph on
v
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
v
\emph default
 is Null, where Null is defined as the empty list 
\family typewriter
'()
\family default
.
\end_layout

\begin_layout LyX-Code
(zero? 
\emph on
v
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
v
\emph default
 = 0.
\end_layout

\begin_layout LyX-Code
(one? 
\emph on
v
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
v = 1.
\end_layout

\begin_layout LyX-Code
(eq? 
\emph on
x y
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
x 
\emph default
and 
\emph on
y
\emph default
 are the same object.
\end_layout

\begin_layout LyX-Code
(symbol? 
\emph on
v
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
v
\emph default
 is a symbol: ie.
 a quoted name such as 
\emph on
'foo.

\emph default
 See 
\emph on
quote
\emph default
 in 3.4.
\end_layout

\begin_layout LyX-Code
(atom? 
\emph on
v
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
v
\emph default
 is an atom: ie.
 a number, symbol, or procedure, rather than another list or Null.
\end_layout

\begin_layout LyX-Code
(lat? 
\emph on
l
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
l
\emph default
 is a list composed solely of atoms.
\end_layout

\begin_layout LyX-Code
(and 
\emph on
expr ...
\emph default
)
\end_layout

\begin_layout Standard
Returns True only if all given expressions are True.
 
\end_layout

\begin_layout LyX-Code
(or 
\emph on
expr
\emph default
 ...)
\end_layout

\begin_layout Standard
Returns True if any given expression is True.
 
\end_layout

\begin_layout LyX-Code
(not 
\emph on
v
\emph default
)
\end_layout

\begin_layout Standard
Returns True if 
\emph on
v
\emph default
 is False, else returns False.
\end_layout

\begin_layout LyX-Code
else 
\end_layout

\begin_layout Standard
A special keyword for True, used as a literal in conditional statements.
\end_layout

\begin_layout LyX-Code
True 
\end_layout

\begin_layout Standard
The boolean truth value.
 Actually an alias for #t in the Racket implementation.
\end_layout

\begin_layout LyX-Code
False
\end_layout

\begin_layout Standard
The boolean false value.
 Actually an alias for #f in the Racket implementation.
\end_layout

\begin_layout LyX-Code
Null
\end_layout

\begin_layout Standard
An alias for the empty list
\family typewriter
 '()
\family default
.
\end_layout

\begin_layout Subsection
Syntax and Evaluation
\end_layout

\begin_layout LyX-Code
quote 
\end_layout

\begin_layout LyX-Code
quasiquote 
\end_layout

\begin_layout LyX-Code
unquote
\end_layout

\begin_layout LyX-Code
unquote-splicing 
\end_layout

\begin_layout LyX-Code
error
\end_layout

\begin_layout LyX-Code
run 
\end_layout

\begin_layout LyX-Code
rem 
\end_layout

\begin_layout LyX-Code
def macro 
\end_layout

\begin_layout LyX-Code
apply
\end_layout

\begin_layout Subsection
Input and Output
\end_layout

\begin_layout LyX-Code
print (& lit)
\end_layout

\begin_layout LyX-Code
? 
\end_layout

\begin_layout LyX-Code
input (stx) 
\end_layout

\begin_layout LyX-Code
using
\end_layout

\begin_layout Subsection
Lists
\end_layout

\begin_layout LyX-Code
list
\end_layout

\begin_layout LyX-Code
join 
\end_layout

\begin_layout LyX-Code
head 
\end_layout

\begin_layout LyX-Code
tail 
\end_layout

\begin_layout LyX-Code
map 
\end_layout

\begin_layout LyX-Code
filter 
\end_layout

\begin_layout LyX-Code
len 
\end_layout

\begin_layout LyX-Code
foldr 
\end_layout

\begin_layout LyX-Code
foldl 
\end_layout

\begin_layout LyX-Code
reverse 
\end_layout

\begin_layout LyX-Code
index 
\end_layout

\begin_layout LyX-Code
index*
\end_layout

\begin_layout LyX-Code
inlst 
\end_layout

\begin_layout LyX-Code
left 
\end_layout

\begin_layout LyX-Code
right 
\end_layout

\begin_layout LyX-Code
mid 
\end_layout

\begin_layout LyX-Code
slice 
\end_layout

\begin_layout LyX-Code
append1 
\end_layout

\begin_layout LyX-Code
append 
\end_layout

\begin_layout LyX-Code
subst 
\end_layout

\begin_layout LyX-Code
heads 
\end_layout

\begin_layout LyX-Code
sort 
\end_layout

\begin_layout LyX-Code
zip 
\end_layout

\begin_layout LyX-Code
zipwith
\end_layout

\begin_layout Subsection
Strings
\end_layout

\begin_layout LyX-Code
=$
\end_layout

\begin_layout LyX-Code
&
\end_layout

\begin_layout LyX-Code
list$
\end_layout

\begin_layout LyX-Code
str$
\end_layout

\begin_layout LyX-Code
empty$?
\end_layout

\begin_layout LyX-Code
len$ 
\end_layout

\begin_layout LyX-Code
list& 
\end_layout

\begin_layout LyX-Code
head$ 
\end_layout

\begin_layout LyX-Code
tail$ 
\end_layout

\begin_layout LyX-Code
left$
\end_layout

\begin_layout LyX-Code
right$ 
\end_layout

\begin_layout LyX-Code
mid$
\end_layout

\begin_layout LyX-Code
slice$
\end_layout

\begin_layout LyX-Code
instr 
\end_layout

\begin_layout LyX-Code
split
\end_layout

\begin_layout Subsection
Math
\end_layout

\begin_layout LyX-Code
+ 
\end_layout

\begin_layout LyX-Code
-
\end_layout

\begin_layout LyX-Code
/ 
\end_layout

\begin_layout LyX-Code
* 
\end_layout

\begin_layout LyX-Code
=
\end_layout

\begin_layout LyX-Code
<
\end_layout

\begin_layout LyX-Code
> 
\end_layout

\begin_layout LyX-Code
^ 
\end_layout

\begin_layout LyX-Code
mod 
\end_layout

\begin_layout LyX-Code
abs
\end_layout

\begin_layout LyX-Code
one?
\end_layout

\begin_layout LyX-Code
even? 
\end_layout

\begin_layout LyX-Code
odd?
\end_layout

\begin_layout LyX-Code
sgn 
\end_layout

\begin_layout LyX-Code
inc 
\end_layout

\begin_layout LyX-Code
dec 
\end_layout

\begin_layout LyX-Code
exp 
\end_layout

\begin_layout LyX-Code
sin 
\end_layout

\begin_layout LyX-Code
cos 
\end_layout

\begin_layout LyX-Code
tan
\end_layout

\begin_layout Subsection
Things
\end_layout

\begin_layout LyX-Code
describe
\end_layout

\begin_layout LyX-Code
send 
\end_layout

\begin_layout LyX-Code
Self
\end_layout

\begin_layout Subsection
Theory
\end_layout

\begin_layout LyX-Code
Y 
\end_layout

\begin_layout LyX-Code
partial 
\end_layout

\begin_layout LyX-Code
compose
\end_layout

\end_body
\end_document
