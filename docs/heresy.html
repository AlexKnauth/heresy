<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>The Heresy Programming Language</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="file:///C:/Users/BearBear/Documents/GitHub/heresy/docs/heresy.html" class="tocviewselflink" data-pltdoc="x">The Heresy Programming Language</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="file:///C:/Users/BearBear/Documents/GitHub/heresy/docs/heresy.html#%28part._.The_.Heresy_.Rules%29" class="tocviewlink" data-pltdoc="x">The Heresy Rules</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="file:///C:/Users/BearBear/Documents/GitHub/heresy/docs/heresy.html#%28part._.Heresy_.Syntax_and_.Conventions%29" class="tocviewlink" data-pltdoc="x">Heresy Syntax and Conventions</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="file:///C:/Users/BearBear/Documents/GitHub/heresy/docs/heresy.html#%28part._.Heresy_.Reference%29" class="tocviewlink" data-pltdoc="x">Heresy Reference</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.The_.Heresy_.Programming_.Language%29" class="tocsubseclink" data-pltdoc="x">The Heresy Programming Language</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Heresy_.Rules%29" class="tocsubseclink" data-pltdoc="x">The Heresy Rules</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Heresy_.Syntax_and_.Conventions%29" class="tocsubseclink" data-pltdoc="x">Heresy Syntax and Conventions</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Heresy_.Reference%29" class="tocsubseclink" data-pltdoc="x">Heresy Reference</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Declarations%29" class="tocsubseclink" data-pltdoc="x">Declarations</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Conditionals_and_.Loops%29" class="tocsubseclink" data-pltdoc="x">Conditionals and Loops</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.Predicates_and_.Logic%29" class="tocsubseclink" data-pltdoc="x">Predicates and Logic</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.Syntax_and_.Evaluation%29" class="tocsubseclink" data-pltdoc="x">Syntax and Evaluation</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="#%28part._.Input_and_.Output%29" class="tocsubseclink" data-pltdoc="x">Input and Output</a></td></tr><tr><td><span class="tocsublinknumber">3.6<tt>&nbsp;</tt></span><a href="#%28part._.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists</a></td></tr><tr><td><span class="tocsublinknumber">3.7<tt>&nbsp;</tt></span><a href="#%28part._.Strings%29" class="tocsubseclink" data-pltdoc="x">Strings</a></td></tr><tr><td><span class="tocsublinknumber">3.8<tt>&nbsp;</tt></span><a href="#%28part._.Math%29" class="tocsubseclink" data-pltdoc="x">Math</a></td></tr><tr><td><span class="tocsublinknumber">3.9<tt>&nbsp;</tt></span><a href="#%28part._.Things%29" class="tocsubseclink" data-pltdoc="x">Things</a></td></tr><tr><td><span class="tocsublinknumber">3.10<tt>&nbsp;</tt></span><a href="#%28part._.Theory%29" class="tocsubseclink" data-pltdoc="x">Theory</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">6.1.1</span></div><h2><a name="(part._.The_.Heresy_.Programming_.Language)"></a>The Heresy Programming Language</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">John S. Berry III</p></span></div><p>The Heresy language is a functional Lisp/Scheme dialect implemented in Racket, with syntax inspired by the BASIC family of programming languages. It&rsquo;s principle goals are to provide a simple core language for BASIC and other programmers to experiment with and learn how to program functionally.</p><p>This document will detail the general philosophy of the Heresy language, such as exists, as well as the language syntax and functions.</p><p>The Heresy language was created by John S. Berry III with additional contributions from many others in the Racket community.</p><p>Heresy and this documentation are Copyright (c) 2014 John S. Berry III and released under the terms of the GNU LGPL.</p><h3>1<tt>&nbsp;</tt><a name="(part._.The_.Heresy_.Rules)"></a>The Heresy Rules</h3><p>The Heresy language is developed according to a few basic "ground rules," which the author and contributors attempt to follow in developing new features and functions for the language. These are as follows:</p><ol><li><p><span style="font-weight: bold">Heresy is BASIC</span> &#8212;<wbr></wbr> Heresy is inspired by BASIC, and aims to be at least somewhat easy for BASIC programmers to learn. Mostly this means we prefer BASIC names for functions over the Lisp name, and naming conventions like the $ for string functions.</p></li><li><p><span style="font-weight: bold">Heresy is a Lisp</span> &#8212;<wbr></wbr> Heresy is still a Lisp, and loves simple syntax and s-expressions. While it makes use of some sugaring like literal keywords for certain common primitives, these are best used sparingly. Heresy is the Diet Coke of Evil, just one calorie, not quite evil enough.</p></li><li><p><span style="font-weight: bold">Heresy is functional</span> &#8212;<wbr></wbr> Functional, but not Haskell. It is not intended solely as a vehicle for absolute functional purity. I love Haskell. You love Haskell. We don&#8217;t need to write another Haskell. Think more in terms of a lower-calorie, more intelligible Clojure.</p></li><li><p><span style="font-weight: bold">Heresy is for learning</span> &#8212;<wbr></wbr> Heresy started as a learning project, a chance to learn how Lisp and functional programming really work on a practical level. I hope that, in time, it can be that for others as well, especially those who grew up with BASIC like myself and still sometimes struggle to get their head around the functional style. In particular, this means the Heresy-written portions of the source are generally written in as clear a manner as possible, as they are intended to be self-teaching.</p></li><li><p><span style="font-weight: bold">Heresy is an experiment</span> &#8212;<wbr></wbr> Heresy is an experimental language. It&#8217;s very DNA is as a mad idea that came to life, and it&#8217;s development should be ready and willing to embrace new mad ideas and run with them. This is where carry came from, and I hope to have more mad ideas in the future.</p></li><li><p><span style="font-weight: bold">Heresy is for everyone</span> &#8212;<wbr></wbr> As a statement of culture, the Heresy community welcomes the contribution of all people, who taste equally delicious to the jaws of mighty Cthulhu. No discrimination, harassment, or any other mistreatment of contributors on the basis of age, race, sexuality, or gender will <span style="font-weight: bold">ever</span> be tolerated by myself or anyone else who wishes to be part of this project.</p></li></ol><h3>2<tt>&nbsp;</tt><a name="(part._.Heresy_.Syntax_and_.Conventions)"></a>Heresy Syntax and Conventions</h3><p>Generally speaking, Heresy follows standard s-expression syntax as expected from any Lisp, being composed of parenthesized sequences of terms in Polish notation. Each sequence thus begins with an operator or function, and any number of arguments or additional s-expressions as needed.</p><p>There are however a few exceptions to usual expectations in the case of certain special forms like <span class="RktSym">for</span>, <span class="RktSym">def</span>, and <span class="RktSym">if</span>. These make use of additional literal terms as part of their syntax, to provide more clarity and similarity to BASIC-style syntax.</p><p>In accordance with that goal, Heresy also follows certain naming conventions as a matter of style. Functions which produce a string value are appended with <span class="RktSym">$</span>, and in general where a naming conflict between two similar functions in Racket/Scheme and BASIC exists, prefer BASIC.</p><p>When borrowing BASIC syntax and naming for use in Heresy, the author has generally relied chiefly on QBASIC and ECMA BASIC for reference.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Heresy_.Reference)"></a>Heresy Reference</h3><h4>3.1<tt>&nbsp;</tt><a name="(part._.Declarations)"></a>Declarations</h4><p>def (fn)
let
fn
import rkt
require/provide</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Conditionals_and_.Loops)"></a>Conditionals and Loops</h4><p>if
select
select case
for
do
do loop
break
carry
cry</p><h4>3.3<tt>&nbsp;</tt><a name="(part._.Predicates_and_.Logic)"></a>Predicates and Logic</h4><p>list?
null?
zero?
eq?
symbol?
atom?
lat?
and or not else
True False Null</p><h4>3.4<tt>&nbsp;</tt><a name="(part._.Syntax_and_.Evaluation)"></a>Syntax and Evaluation</h4><p>quote
quasiquote
unquote
unquote-splicing
error
run
rem
def macro
apply</p><h4>3.5<tt>&nbsp;</tt><a name="(part._.Input_and_.Output)"></a>Input and Output</h4><p>print (&amp; lit)
?
input (stx)
using</p><h4>3.6<tt>&nbsp;</tt><a name="(part._.Lists)"></a>Lists</h4><p>list
join
head
tail
map
filter
len
foldr
foldl
reverse
index
index*
inlst
left
right
mid
slice
append1
append
subst
heads
sort
zip
zipwith</p><h4>3.7<tt>&nbsp;</tt><a name="(part._.Strings)"></a>Strings</h4><p>=$
&amp;
list$
str$
empty$?
len$
list&amp;
head$
tail$
left$
right$
mid$
slice$
instr
split</p><h4>3.8<tt>&nbsp;</tt><a name="(part._.Math)"></a>Math</h4><p>+ - / * = &lt; &gt;
^
mod
abs
one?
even?
odd?
sgn
inc
dec
exp
sin
cos
tan</p><h4>3.9<tt>&nbsp;</tt><a name="(part._.Things)"></a>Things</h4><p>describe
send
Self</p><h4>3.10<tt>&nbsp;</tt><a name="(part._.Theory)"></a>Theory</h4><p>Y
partial
compose</p></div></div><div id="contextindicator">&nbsp;</div></body></html>